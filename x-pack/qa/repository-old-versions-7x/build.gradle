/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import org.elasticsearch.gradle.Architecture
import org.elasticsearch.gradle.OS
import org.elasticsearch.gradle.Version
import org.elasticsearch.gradle.internal.BwcVersions
import org.elasticsearch.gradle.internal.info.BuildParams
import org.elasticsearch.gradle.internal.test.AntFixture
import org.elasticsearch.gradle.testclusters.StandaloneRestIntegTestTask
import org.elasticsearch.gradle.transform.UnzipTransform
import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE

apply plugin: 'elasticsearch.jdk-download'
apply plugin: 'elasticsearch.internal-testclusters'
apply plugin: 'elasticsearch.internal-java-rest-test'
apply plugin: 'elasticsearch.internal-yaml-rest-test'
apply plugin: 'elasticsearch.rest-resources'

jdks {
  legacy {
    vendor = 'adoptium'
    version = '8u302+b08'
    platform = OS.current().name().toLowerCase()
    architecture = Architecture.current().name().toLowerCase()
  }
}

restResources {
  restApi {
    include '_common', 'search'
  }
  restTests {
    includeCore 'search/390_doc_values_search.yml'
  }
}

if (OS.current() == OS.MAC && Architecture.current() == Architecture.AARCH64) {
  jdks.legacy.vendor = 'zulu'
  jdks.legacy.distributionVersion = '8.56.0.23'
}

if (OS.current() == OS.WINDOWS) {
  logger.warn("Disabling repository-old-versions tests because we can't get the pid file on windows")
} else {
  int currentMajorVersion = org.elasticsearch.gradle.VersionProperties.elasticsearchVersion.major
  for (String versionString : ['7.17.25']) {
    Version version = Version.fromString(versionString)
    String versionNoDots = version.toString().replace('.', '_')
//    String configName = "es${versionNoDots}"

//    def config = configurations.create(configName)
//    config.getAttributes().attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE);
//    dependencies.add(configName, artifact)

    String repoLocation = "${buildDir}/cluster/shared/repo/${versionNoDots}"
    String clusterName = versionNoDots

    def testClusterProvider = testClusters.register(clusterName) {
      testDistribution = 'DEFAULT'
      numberOfNodes = 2
      versions = [project.version, project.version] // to test full cluster restart

      setting 'path.repo', repoLocation, IGNORE_VALUE
      setting 'xpack.license.self_generated.type', 'trial'

      setting 'xpack.security.enabled', 'true'
      user username: 'admin', password: 'admin-password', role: 'superuser'

      setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'
      setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'
    }

    def oldCluster = testClusters.register("oldES${versionNoDots}Cluster") {
      testDistribution = 'DEFAULT'
      numberOfNodes = 1
      versions = [versionString]
      setting 'path.repo', repoLocation, IGNORE_VALUE
      setting 'xpack.license.self_generated.type', 'trial'
      setting 'xpack.security.enabled', 'true'
      user username: 'admin', password: 'admin-password', role: 'superuser'
      setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'
      setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'
    }

    tasks.register("javaRestTestBeforeRestart#${versionNoDots}", StandaloneRestIntegTestTask) {
      useCluster testClusterProvider
      useCluster testClusters.named("oldES${versionNoDots}Cluster")
      doFirst {
        delete(repoLocation)
        mkdir(repoLocation)
      }
      systemProperty 'tests.after_restart', 'false'
    }

    tasks.register("javaRestTestAfterRestart#${versionNoDots}", StandaloneRestIntegTestTask) {
      useCluster testClusterProvider
      dependsOn "javaRestTestBeforeRestart#${versionNoDots}"
      useCluster testClusters.named("oldES${versionNoDots}Cluster")
      systemProperty 'tests.after_restart', 'true'

      doFirst {
        testClusterProvider.get().goToNextVersion()
      }
    }

    tasks.matching { it.name.startsWith("javaRestTest") && it.name.endsWith(versionNoDots) }.configureEach {
      doFirst {
        def oldClusterPortProvider = testClusters.named("oldES${versionNoDots}Cluster").map { cluster ->
          def local = cluster.allHttpSocketURI.find { it.startsWith("127.0.0.1")}
          return local.substring(local.lastIndexOf(':') + 1)
        }
        it.nonInputProperties.systemProperty "tests.es.port", "${-> oldClusterPortProvider.get()}"
        println "oldClusterPortProvider " + oldClusterPortProvider.get()
        println "allRemoteAccessPortURI " + testClusters.named("oldES${versionNoDots}Cluster").get().allRemoteAccessPortURI
        println "allHttpSocketURI " + testClusters.named("oldES${versionNoDots}Cluster").get().allHttpSocketURI
        println "httpSocketURI " + testClusters.named("oldES${versionNoDots}Cluster").get().httpSocketURI
      }
      it.nonInputProperties.systemProperty "tests.repo.location", repoLocation
      it.systemProperty "tests.es.version", version.toString()

      /* Use a closure on the string to delay evaluation until right before we
       * run the integration tests so that we can be sure that the file is
       * ready. */
      it.nonInputProperties.systemProperty('tests.rest.cluster', "${-> testClusterProvider.get().allHttpSocketURI.join(",")}")
      it.nonInputProperties.systemProperty('tests.clustername', "${-> testClusterProvider.get().getName()}")
    }

    tasks.named("check").configure {
      dependsOn "javaRestTestAfterRestart#${versionNoDots}"
    }
  }
}

