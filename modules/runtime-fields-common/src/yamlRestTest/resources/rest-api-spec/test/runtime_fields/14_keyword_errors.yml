---
setup:
  - do:
      indices.create:
        index: testindex
        body:
          settings:
            number_of_shards: 1
          mappings:
            runtime:
              first_char:
                type: keyword
                script: |
                  for (s in doc['name']) { emit(s.substring(0,1));}
                on_script_error: continue
              first_char_strict_error:
                type: keyword
                script: |
                  for (s in doc['name']) { emit(s.substring(0,1));}
                on_script_error: fail
            properties:
              name:
                type: keyword

  - do:
      bulk:
        index: testindex
        refresh: true
        body: |
          {"index":{}}
          {"name": "foo"}
          {"index":{}}
          {"name": ""}
          {"index":{}}
          {"name": ["bar", "goo"]}
          {"index":{}}
          {"name": ["bar", ""]}
---
"Query rtf with on_script_error continue":
  - do:
      search:
        index: testindex
        body:
          query:
            match:
              first_char: "f"
          fields: [ name, first_char ]
  - match: { hits.total.value: 1 }
  - match: { hits.hits.0.fields.name: [ foo ] }
  - match: { hits.hits.0.fields.first_char: [ f ] }

  - do:
      search:
        index: testindex
        body:
          query:
            match:
              first_char: "b"
          fields: [ name, first_char ]
  - match: { hits.total.value: 1 }
  - match: { hits.hits.0.fields.name: [ bar, goo ] }
  - match: { hits.hits.0.fields.first_char: [ b, g ] }
---
"Query rtf with on_script_error fail":
  - do:
      catch: /type=script_exception, reason=runtime error/
      search:
        index: testindex
        body:
          query:
            match:
              first_char_strict_error: "f"
          fields: [ name, first_char_strict_error ]

---
"Aggregate on rtf with on_script_error continue":
  - do:
      search:
        index: testindex
        body:
          aggs:
            firstchar:
              terms:
                field: first_char
  - length: { aggregations.firstchar.buckets: 3 }
  - match: { aggregations.firstchar.buckets.0.key: "b" }
  - match: { aggregations.firstchar.buckets.1.key: "f" }
  - match: { aggregations.firstchar.buckets.2.key: "g" }

---
"Aggregate on rtf with on_script_error fail":
  - do:
      catch: /type=script_exception, reason=runtime error/
      search:
        index: testindex
        body:
          aggs:
            firstchar:
              terms:
                field: first_char_strict_error

---
"Fields retrieval with ignoring error":
  - do:
      search:
        index: testindex
        body:
          query: { match_all: { } }
          fields: [ name, first_char ]
          sort: ["name"]
  - match: { hits.total.value: 4 }
  - match: { hits.hits.0.fields.name: [ "" ] }
  - is_false: hits.hits.0.fields.first_char
  - match: { hits.hits.1.fields.name: [ bar, "" ] }
  - is_false: hits.hits.1.fields.first_char
  - match: { hits.hits.2.fields.name: [ bar, goo ] }
  - match: { hits.hits.2.fields.first_char: [ b, g ] }
  - match: { hits.hits.3.fields.name: [ foo ] }
  - match: { hits.hits.3.fields.first_char: [ f ] }


---
"Fields retrieval with failing on error":
  - do:
      catch: /type=script_exception, reason=runtime error/
      search:
        index: testindex
        body:
          query: { match_all: { } }
          fields: [ name, first_char_strict_error ]

---
"Sorting with ignoring error":
  - do:
      search:
        index: testindex
        body:
          query: { match_all: { } }
          fields: [ name ]
          sort: first_char
  - match: { hits.total.value: 4 }
  - match: { hits.hits.0.sort: [ b ] }
  - match: { hits.hits.1.sort: [ f ] }
  - match: { hits.hits.2.sort: [ null ] }
  - match: { hits.hits.3.sort: [ null ] }

---
"Sorting with with failing on error":
  - do:
      catch: /type=script_exception, reason=runtime error/
      search:
        index: testindex
        body:
          query: { match_all: { } }
          fields: [ name ]
          sort: first_char_strict_error

---
"Query search time rtf with on_script_error continue":
  - do:
      search:
        index: testindex
        body:
          query:
            match:
              first_char_search: "f"
          fields: [ name, first_char_search ]
          runtime_mappings:
            first_char_search:
              type: keyword
              script: |
                for (s in doc['name']) { emit(s.substring(0,1));}
              on_script_error: continue

  - match: { hits.total.value: 1 }
  - match: { hits.hits.0.fields.name: [ foo ] }
  - match: { hits.hits.0.fields.first_char_search: [ f ] }

---
"Query search time rtf with on_script_error fail":
  - do:
      catch: /type=script_exception, reason=runtime error/
      search:
        index: testindex
        body:
          query:
            match:
              first_char_search: "f"
          fields: [ name, first_char_search ]
          runtime_mappings:
            first_char_search:
              type: keyword
              script: |
                for (s in doc['name']) { emit(s.substring(0,1));}
              on_script_error: fail

---
"Change error behaviour for lenient runtime field":

  - do:
      indices.put_mapping:
        index: testindex
        body:
          runtime:
            first_char_variant:
              type: keyword
              script: |
                for (s in doc['name']) { emit(s.substring(0,1));}

  - do:
      catch: /type=script_exception, reason=runtime error/
      search:
        index: testindex
        body:
          query:
            match:
              first_char_variant: "f"

  - do:
      indices.put_mapping:
        index: testindex
        body:
          runtime:
            first_char_variant:
              type: keyword
              script: |
                for (s in doc['name']) { emit(s.substring(0,1));}
              on_script_error: continue

  - do:
      search:
        index: testindex
        body:
          query:
            match:
              first_char_variant: "f"
          fields: [ name, first_char_variant ]
  - match: { hits.total.value: 1 }
  - match: { hits.hits.0.fields.name: [ foo ] }
  - match: { hits.hits.0.fields.first_char_variant: [ f ] }
