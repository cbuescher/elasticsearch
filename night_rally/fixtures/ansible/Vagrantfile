# vi: set ft=ruby :
# -*- ruby -*-

require "ipaddr"
require "net/http"


def successive_ips(base_ip, num_of_successive_ips)
  ip = base_ip.clone
  num_of_successive_ips.times.map { |n| ip = ip.succ; ip }
end

base_ip = "192.168.180.10"
boxname = "ubuntu/bionic64"
box_version = "20201123.0.0"

default_loaddriver_cpus = 2
default_target_cpus = ENV.fetch("VAGRANT_TARGET_CPUS", "2")
default_target_node_count = 3
target_node_ip_addresses = successive_ips(base_ip, default_target_node_count)
# Memory settings in MiB
default_load_driver_memory = ENV.fetch("VAGRANT_LOAD_DRIVER_MEMORY", "2048")
default_target_memory = ENV.fetch("VAGRANT_TARGET_MEMORY", "16384")

domain_name = "benchmarks.ci.vagrant"

nodes = [{ hostname: "coordinator", domain: domain_name, autostart: true, box: boxname, box_version: box_version, memory: default_load_driver_memory, cpus: default_loaddriver_cpus }]

# target-nodes
for i in 1..default_target_node_count
  nodes += [{ hostname: "target%02d" % [i], domain: domain_name, autostart: true, box: boxname, box_version: box_version, memory: default_target_memory.to_i, cpus: default_target_cpus }]
end

rally_repo = ENV.fetch("RALLY_REPO", "https://github.com/elastic/rally.git")
rally_branch = ENV.fetch("RALLY_BRANCH", "master")
rally_sha = ENV.fetch("RALLY_SHA", "")

extra_disks = {
  :coordinator => {
    :rally_disk => {
      # needed for benchmark data mostly
      :scsi_port => 2,
      :scsi_device => 0,
      :block_device => "/dev/sdc",
      :mount_point => "/var/lib/jenkins/.rally",
      :size_mib => ENV.fetch("VAGRANT_RALLY_DISK_MIB", 80*1024),
      :fsck_order => 2,
    }
  },
  :target => {
    :rally_disk => {
      # needed mostly for building ES from source
      :scsi_port => 2,
      :scsi_device => 0,
      :block_device => "/dev/sdc",
      :mount_point => "/var/lib/jenkins/.rally",
      :size_mib => 10480,
      :fsck_order => 2,
    },
    :races_disk => {
      :scsi_port => 3,
      :scsi_device => 0,
      :block_device => "/dev/sdd",
      :mount_point => "/var/lib/jenkins/.rally/benchmarks/races",
      :size_mib => 20480,
      :fsck_order => 3,
    }
  }
}

def create_addon_disks(is_coordinator, hostname, vbox, extra_disks)
  node_role = is_coordinator ? :coordinator : :target
  rally_disk_file = File.realpath("vagrantdisk").to_s + "/#{hostname}_rally_disk.vdi"
  rally_disk_size_mib = extra_disks[node_role][:rally_disk][:size_mib]
  rally_disk_scsi_port = extra_disks[node_role][:rally_disk][:scsi_port]
  rally_disk_scsi_device = extra_disks[node_role][:rally_disk][:scsi_device]

  vbox.customize ['createmedium', "disk", '--filename', rally_disk_file, '--size', rally_disk_size_mib, '--format', 'VDI']
  vbox.customize ['storageattach', :id, '--storagectl', 'SCSI', '--port', rally_disk_scsi_port, '--device', rally_disk_scsi_device, '--type', 'hdd', '--medium', rally_disk_file]

  if ! is_coordinator
    races_disk_file = File.realpath("vagrantdisk").to_s + "/#{hostname}_races_disk.vdi"
    races_disk_size_mib = extra_disks[node_role][:races_disk][:size_mib]
    races_disk_scsi_port = extra_disks[node_role][:races_disk][:scsi_port]
    races_disk_scsi_device = extra_disks[node_role][:races_disk][:scsi_device]

    vbox.customize ['createmedium', "disk", '--filename', races_disk_file, '--size', races_disk_size_mib, '--format', 'VDI']
    vbox.customize ['storageattach', :id, '--storagectl', 'SCSI', '--port', races_disk_scsi_port, '--device', races_disk_scsi_device, '--type', 'hdd', '--medium', races_disk_file]
  end
end

def setup_extra_disks(is_coordinator, extra_disks)
  script = "set -eo pipefail\n"

  node_role = is_coordinator ? :coordinator : :target
  script << disk_init_generator(extra_disks[node_role][:rally_disk])

  if ! is_coordinator
    script << " \n "
    script << disk_init_generator(extra_disks[:target][:races_disk])
  end
  return script
end

def disk_init_generator(disk_conf)
  <<~EOF
    basedir="/var/lib/jenkins/.rally"
    mountdir=#{disk_conf[:mount_point]}
    mkdir -p $mountdir
    # as $mountdir can be deep under $basedir (and we create parent missing directories with -p), we need to chown the $basedir
    chown -R jenkins:jenkins $basedir
    chmod -R 775 $basedir
    mkfs.ext4 #{disk_conf[:block_device]}
    echo \"#{disk_conf[:block_device]} $mountdir ext4 defaults,data=writeback 0 #{disk_conf[:fsck_order]}\" >>/etc/fstab
    mount $mountdir
    chown -R jenkins:jenkins $mountdir
    chmod -R 775 $mountdir
  EOF
end

def disable_apt_frontend
  <<~EOF
    set -eo pipefail
    sed -i 's/\(dpkg-preconfigure\) --apt/\1 --frontend=noninteractive --apt/' /etc/apt/apt.conf.d/70debconf
  EOF
end

def curl_wrapper(max_time=10, retry_max_time=100, silent=true)
  # Return a curl command prefix that always retries on failure
  basic_command = "curl -SfL --connect-timeout 5 --max-time #{max_time} --retry 5 --retry-max-time #{retry_max_time}"
  if silent
    return basic_command << " -s"
  else
    return basic_command
  end
end

def rally_sudoers
  # Use single quotes to avoid interpolating EOF2 intended for bash
  # tilde before 'EOF' allows indenting heredoc without passing the extra leading spaces to actual bash command
  <<~'EOF'
    set -eo pipefail
    cat >/etc/sudoers.d/rally_user <<EOF2
    Defaults:rally !requiretty
    rally ALL = (ALL) NOPASSWD: ALL
    EOF2
  EOF
end

def install_jenkins_user
  <<~EOF
    set -eo pipefail
    groupadd -g 1010 jenkins
    useradd -u 1010 -g 1010 -s /bin/bash -m -k /etc/skel -d /var/lib/jenkins jenkins
    mkdir /var/lib/jenkins/.ssh

    cp /night_rally/night_rally/fixtures/ansible/.vagrantssh/id_rsa /var/lib/jenkins/.ssh/rally
    cp /night_rally/night_rally/fixtures/ansible/.vagrantssh/id_rsa.pub /var/lib/jenkins/.ssh/authorized_keys
    chown -R jenkins:jenkins /var/lib/jenkins/.ssh
    chmod -R 0600 /var/lib/jenkins/.ssh/rally
  EOF
end

def install_rally_user
  <<~EOF
    set -eo pipefail
    groupadd -g 1011 rally
    useradd -u 1011 -g 1011 -s /bin/bash -m -k /etc/skel -d /home/rally rally
    mkdir /home/rally/.ssh

    cp /night_rally/night_rally/fixtures/ansible/.vagrantssh/id_rsa /home/rally/.ssh/rally
    cp /night_rally/night_rally/fixtures/ansible/.vagrantssh/id_rsa.pub /home/rally/.ssh/authorized_keys
    chown -R rally:rally /home/rally/.ssh
  chmod -R 0600 /home/rally/.ssh/rally
  EOF
end

def install_vault
  <<~EOF
    set -eo pipefail
    CUR_HOME=$HOME
    #{curl_wrapper} -o ${CUR_HOME}/vault.zip https://releases.hashicorp.com/vault/1.1.1/vault_1.1.1_linux_amd64.zip
    sudo unzip ${CUR_HOME}/vault.zip -d /usr/local/bin
    sudo chmod +x /usr/local/bin/vault
    rm ${CUR_HOME}/vault.zip
  EOF
end

def install_rally_ssh_key
  # Deploy a key that allows us to read from private GH track repos like elastic/rally-internal-tracks
  <<~EOF
  set -eo pipefail
  cd /var/lib/jenkins
  sudo -iu jenkins bash -c "vault read -field=private-key /secret/ci/elastic-night-rally/employees/ssh/rally >~/.ssh/id_rsa && chmod 0600 ~/.ssh/id_rsa && ssh-keyscan github.com >> ~/.ssh/known_hosts"
  EOF
end

def install_rally_source(rally_repo, rally_branch, rally_sha)
  # Remove OS packages for python3-pip; we prefer per account installation of pip3
  <<~EOF
    set -eo pipefail
    apt-get update
    apt-get purge -y python3\*-pip
    apt-get install -y build-essential curl libbz2-dev libncurses5-dev libncursesw5-dev libreadline-dev libsqlite3-dev libssl-dev llvm wget xz-utils zlib1g-dev unzip jq
    cat >/rally-install.sh <<'EOF2'
    #!/usr/bin/env bash

    cd /var/lib/jenkins
    git clone https://github.com/pyenv/pyenv.git ~/.pyenv
    # Per the installation guide, pyenv needs to be added to PATH before ~/.profile sources ~/.bashrc
    # https://github.com/pyenv/pyenv/blob/master/README.md#basic-github-checkout
    sed -i '/^\\s*\\. "\\$HOME\\/\\.bashrc"$/i \\\texport PATH="\\$HOME/.pyenv/bin:\\$HOME/.local/bin:\\$PATH"\\\n\\\teval "\\$(pyenv init --path)"\\\n\\\n' /var/lib/jenkins/.profile
    echo 'eval "\$(pyenv init --path)"' >> /var/lib/jenkins/.profile
    echo 'eval "\$(pyenv init -)"' >> /var/lib/jenkins/.bashrc
    source /var/lib/jenkins/.profile
    pyenv install 3.8.0
    pyenv local 3.8.0
    echo 'pyenv local 3.8.0' >> /var/lib/jenkins/.profile
    mkdir src bin
    cd src
    git clone #{rally_repo} --branch #{rally_branch}
    cd rally
    if [[ ! -z \"#{rally_sha}\" ]]; then git checkout #{rally_sha}; fi
    python3 -m pip install --upgrade pip wheel
    python3 -m pip install --quiet --user --upgrade --editable .
    cd /var/lib/jenkins
    ln -s $PWD/src/rally/rally $PWD/bin/rally
    ln -s $PWD/src/rally/rallyd $PWD/bin/rallyd
    ln -s $PWD/night_rally/night_rally.sh $PWD/bin/night_rally
    EOF2

    chmod ugo+x /rally-install.sh
    sudo -iu jenkins /rally-install.sh
  EOF
end

def tweak_es_sysctl
  <<~EOF
    # Tweak sysctl so ES will start.
    grep -q '^vm.max_map_count=' /etc/sysctl.conf || ( \
      echo 'vm.max_map_count=262144' >> /etc/sysctl.conf && \
      sysctl --load \
    )
  EOF
end

def install_night_rally_test_script(base_ip, target_node_ip_addresses)
  <<~EOF
    cat >/var/lib/jenkins/env_test_script <<'EOF2'
    #export FIXTURES=drop-caches,trim,initialize-data-disk
    # Speed things up by starting with zero string fixtures, but allow overriding via env var
    export FIXTURES=${FIXTURES:-}
    export COORDINATING_NODES=#{base_ip}
    export TARGET_HOSTS="#{target_node_ip_addresses.join(',')}"
    export TEST_MODE=YES
    EOF2

    cat >/var/lib/jenkins/test_nightly.sh <<"EOF2"
    #!/usr/bin/env bash
    set -eo pipefail
    source /var/lib/jenkins/env_test_script

    function check_exit_code {
      RED='\033[0;31m'
      NO_COLOR='\033[0m'
      printf "${RED}One of the scripts failed! Search for failures in the above output.${NO_COLOR}\n"
    }
    trap check_exit_code ERR

    # release-license is trial basic just because it's the default option in the JJB dropdown; ignored in nightly mode but used to copy the results as master in release charts
    night_rally --target-host="${TARGET_HOSTS}" --race-configs="resources/race-configs-group-1.json" --effective-start-date="" --mode="nightly" --version="master" --release-license="trial" --runtime-jdk="bundled"
    night_rally --target-host="${TARGET_HOSTS}" --race-configs="resources/race-configs-group-2.json" --effective-start-date="" --mode="nightly" --version="master" --release-license="trial" --runtime-jdk="bundled"
    night_rally --target-host="${TARGET_HOSTS}" --race-configs="resources/race-configs-group-3.json" --effective-start-date="" --mode="nightly" --version="master" --release-license="trial" --runtime-jdk="bundled"
    EOF2

    chown jenkins:jenkins /var/lib/jenkins/test_*.sh
    chmod +x /var/lib/jenkins/test_*.sh
  EOF
end


def get_java_version(requirement)
  uri = URI('https://raw.githubusercontent.com/elastic/elasticsearch/master/.ci/java-versions.properties')
  begin
    res = Net::HTTP.get_response(uri)
  rescue Timeout::Error, Errno::EINVAL, Errno::ECONNRESET, EOFError,
    Net::HTTPBadResponse, Net::HTTPHeaderSyntaxError, Net::ProtocolError => e
    puts "Failed to get required Java version: #{e}"
    raise e
  end

  if requirement == "build"
    res.body.match(/^ES_BUILD_JAVA=(\D+)(\d+)$/mi).captures.last
  elsif requirement == "runtime"
    res.body.match(/^ES_RUNTIME_JAVA=(\D+)(\d+)$/mi).captures.last
  end
end


def install_java(major_ver)
  <<~EOF
    set -eo pipefail
    echo "Installing Java version #{major_ver}"
    jdk_url=$(#{curl_wrapper} https://jvm-catalog.elastic.co/jdk/latest_openjdk_#{major_ver}_linux | jq -r .url)
    cd /var/lib/jenkins
    mkdir -p .java/openjdk#{major_ver}
    cd .java/openjdk#{major_ver}
    #{curl_wrapper(max_time=300,retry_max_time=1800,silent=false)} --progress-bar -o java#{major_ver}.tgz $jdk_url
    tar zxf java#{major_ver}.tgz --strip-components=1
    rm -f java#{major_ver}.tgz
    cd ../../
    chown -R jenkins:jenkins .java
  EOF
end

def pass_additional_jenkins_env_vars
  <<~EOF
    set +x -eo pipefail
    cat >>/var/lib/jenkins/.profile <<EOF2
    export VAULT_ADDR=https://vault-ci-prod.elastic.dev
    export RALLY_METRICS_STORE_CREDENTIAL_PATH=${RALLY_METRICS_STORE_CREDENTIAL_PATH:-/secret/ci/elastic-night-rally/es-perf/cloud/vagrant-test-rally-metrics}
    export IN_VAGRANT=YES
    EOF2
  EOF
end

def install_docker
  <<~EOF
    set -eo pipefail
    # Remove older Docker versions
    apt-get remove -y \
      docker \
      docker-engine \
      docker.io \
      containerd \
      runc
    # Install and configure Docker
    apt-get install -y \
      apt-transport-https \
      ca-certificates \
      curl \
      gnupg-agent \
      software-properties-common && \
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=1 apt-key add - && \
    add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" && \
    apt-get update && \
    apt-get install -y docker-ce docker-ce-cli containerd.io && \
    usermod -aG docker jenkins && \
    systemctl enable docker && \
    systemctl start docker
    curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose
  EOF
end

def install_ansible(ansible_version)
  <<~EOF
    sudo -iu jenkins bash -c "python3 -m pip install --user ansible==#{ansible_version}"
  EOF
end

Vagrant.configure(2) do |config|
  use_cachier = false
  if Vagrant.has_plugin?('vagrant-cachier') and not ENV['VAGRANT_NO_CACHIER']
    use_cachier = true
    config.cache.scope = :machine
  end

  ENV['VAGRANT_FORCE_REFRESH_CACHE'] = 'true'
  ip_address = IPAddr.new base_ip

  nodes.each do |node|

    fqdn = node[:hostname] + '.' + node[:domain]

    config.vm.define node[:hostname], autostart: (node[:autostart] || false) do |node_config|
      node_config.vm.box = node[:box] || boxname
      node_config.vm.box_version = box_version
      node_config.vm.hostname = fqdn
      node_config.vm.network :private_network, ip: ip_address.to_s

      is_coordinator = node[:hostname] == "coordinator"

      node_config.vm.provider :virtualbox do |vbox, override_config|
        vbox.name = fqdn
        vbox.memory = node[:memory] || default_memory
        vbox.cpus = node[:cpus]
        override_config.vm.synced_folder '../../..', '/night_rally'

        create_addon_disks(is_coordinator, node[:hostname], vbox, extra_disks)

        if is_coordinator
          override_config.vm.synced_folder "#{Dir.home}/", "/home/vagrant/", type: "rsync", rsync__args: ["-r", "--include=.vault-token", "--exclude=*"]
        end
      end

      node_config.ssh.forward_agent = true
      node_config.vm.provision "shell", inline: disable_apt_frontend
      node_config.vm.provision "shell", inline: tweak_es_sysctl
      node_config.vm.provision "shell", inline: install_jenkins_user
      node_config.vm.provision "shell", inline: pass_additional_jenkins_env_vars, env: {"RALLY_METRICS_STORE_CREDENTIAL_PATH" => ENV["VAULT_NIGHT_RALLY_METRICS_STORE_CREDENTIAL_PATH"]}
      node_config.vm.provision "shell", inline: install_rally_user
      node_config.vm.provision "shell", inline: rally_sudoers
      node_config.vm.provision "shell", inline: install_rally_source(rally_repo, rally_branch, rally_sha)
      node_config.vm.provision "shell", inline: setup_extra_disks(is_coordinator, extra_disks)

      # Make a local copy of night_rally under the jenkins user home dir on the coordinator
      # required because installing night_rally needs write access to the `.egg` directory
      if is_coordinator
        node_config.vm.provision "shell", inline: install_vault
        node_config.vm.provision "shell", inline: <<-EOF
          echo 'sudo rsync -r -o -g --chown=jenkins:jenkins --exclude ".vagrant" --exclude ".venv" --exclude "vagrantdisk" /night_rally /home/vagrant/.vault-token /var/lib/jenkins/' \
            >/home/vagrant/update_jenkins_night_rally.sh
          chmod +x update_jenkins_night_rally.sh
          ./update_jenkins_night_rally.sh

          sudo -iu jenkins bash -c 'cd night_rally; make install'
        EOF

        node_config.vm.provision "shell", inline: install_ansible("2.10.7")
        node_config.vm.provision "shell", inline: install_rally_ssh_key
      end

      node_config.vm.provision "shell", inline: install_night_rally_test_script(base_ip, target_node_ip_addresses)

      # Install docker on target nodes
      if ! is_coordinator
        node_config.vm.provision "shell", inline: install_docker
      end

      # Java 11 is used by default for release benchmarks, so should be installed always
      # https://github.com/elastic/night-rally/issues/114#issuecomment-534100792
      runtime_java_version = get_java_version("runtime")
      build_java_version = get_java_version("build")
      if ! is_coordinator
        node_config.vm.provision "shell", inline: install_java(runtime_java_version)
      end

      if ! is_coordinator && runtime_java_version != build_java_version
        node_config.vm.provision "shell", inline: install_java(build_java_version)
      end

      ip_address = ip_address.succ
    end
  end
end
